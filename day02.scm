(module day02
  (include "utils.scm")
  )

(define (all-to-int arr)
  (if (null? arr)
    '()
    (if (string? arr)
      (string->number arr)
      (cons (string->number (car arr)) (all-to-int (cdr arr)))
      )
    )
  )

(define (parse-spaces-and-numbers arr)
  (if (null? arr)
    '()
    (cons (all-to-int (string-split (car arr) " ")) (parse-spaces-and-numbers (cdr arr)))
    )
  )

(define (min-max arr minimum maximum)
  (if (null? arr)
    (list minimum maximum)
    (if (< (car arr) minimum)
      (if (> (car arr) maximum)
        (min-max (cdr arr) (car arr) (car arr))
        (min-max (cdr arr) (car arr) maximum)
        )
      (if (> (car arr) maximum)
        (min-max (cdr arr) minimum (car arr))
        (min-max (cdr arr) minimum maximum)
        )
      )
    )
  )

(define (diff arr)
  (abs (- (car arr) (cadr arr)))
  )

(define (find-sum arr sum)
  (if (null? arr)
    sum
    (+ (find-sum (cdr arr) sum) (+ sum (diff (min-max (car arr) 10000 0))))
    )
  )

(define (find-divisible-quotient orig-arr arr item pos len)
  (if (eq? pos len)
    #f
    (if (eq? 0 (modulo item (cadr arr)))
      (/ item (cadr arr))
      (if (eq? 0 (modulo (cadr arr) item))
        (/ (cadr arr) item)
        (let ((res (find-divisible-quotient orig-arr (cdr arr) item (+ pos 1) len)))
          (if (number? res)
            res
            (find-divisible-quotient (cdr orig-arr) (cdr orig-arr) (cadr orig-arr) 1 (- len 1))
            )
          )
        )
      )
    )
  )
(define (find-divisible-sum arr sum)
  (if (null? arr)
    sum
    (+ (find-divisible-sum (cdr arr) sum) (+ sum (find-divisible-quotient (car arr) (car arr) (caar arr) 1 (length (car arr)))))
    )
  )

(define (day2 in)
  (display-with-types (find-sum in 0))
  (display " <- part 1\n")
  (display-with-types (find-divisible-sum in 0))
  (display " <- part 2\n")
  )

(day2 (parse-spaces-and-numbers (string-split (read-string (open-input-file "day02in.txt")) "\n")))